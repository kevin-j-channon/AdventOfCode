#pragma once

///////////////////////////////////////////////////////////////////////////////

#include "StaticMap.hpp"

///////////////////////////////////////////////////////////////////////////////

namespace aoc
{
namespace comms
{
namespace BITS
{

///////////////////////////////////////////////////////////////////////////////

using HexStream_t = std::istream;

///////////////////////////////////////////////////////////////////////////////

template<typename Result_T, size_t SIZE>
std::enable_if_t<std::is_integral_v<Result_T>, Result_T> bit_chars_to_value(const std::array<char, SIZE>& bits)
{
	static constexpr auto bit_masks = std::array{
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000000'00000001 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000000'00000010 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000000'00000100 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000000'00001000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000000'00010000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000000'00100000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000000'01000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000000'10000000 },

		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000001'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000010'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00000100'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00001000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00010000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'00100000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'01000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000000'10000000'00000000 },

		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000001'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000010'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00000100'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00001000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00010000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'00100000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'01000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000000'10000000'00000000'00000000 },

		uint64_t{0b00000000'00000000'00000000'00000000'00000001'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000010'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00000100'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00001000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00010000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'00100000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'01000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000000'10000000'00000000'00000000'00000000 },

		uint64_t{0b00000000'00000000'00000000'00000001'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000010'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00000100'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00001000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00010000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'00100000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'01000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000000'10000000'00000000'00000000'00000000'00000000 },

		uint64_t{0b00000000'00000000'00000001'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000010'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00000100'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00001000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00010000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'00100000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'01000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000000'10000000'00000000'00000000'00000000'00000000'00000000 },

		uint64_t{0b00000000'00000001'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000010'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00000100'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00001000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00010000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'00100000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'01000000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000000'10000000'00000000'00000000'00000000'00000000'00000000'00000000 },

		uint64_t{0b00000001'00000000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000010'00000000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00000100'00000000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00001000'00000000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00010000'00000000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b00100000'00000000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b01000000'00000000'00000000'00000000'00000000'00000000'00000000'00000000 },
		uint64_t{0b10000000'00000000'00000000'00000000'00000000'00000000'00000000'00000000 }
	};

	auto out = Result_T{ 0 };

	for (size_t i = 0; i < SIZE; ++i) {
		if (bits[i] != '0') {
			out |= bit_masks[SIZE - i - 1];
		}
	}

	return out;
}
///////////////////////////////////////////////////////////////////////////////

class Streambuf : public std::streambuf
{
public:
	Streambuf(std::streambuf* hex_char_buf)
		: _hex_char_buf{ hex_char_buf }
	{
	}

	std::streambuf::int_type underflow() override
	{
		if (_hex_char_buf->sgetn(&_hex_char, 1) != 1) {
			return traits_type::eof();
		}

		_update_bit_buffer(_hex_char);

		setg(_bit_buffer->data(), _bit_buffer->data(), std::next(_bit_buffer->data(), _bit_buffer->size()));

		return traits_type::to_int_type(*gptr());
	}

	int sync() override
	{
		auto result = this->overflow(traits_type::eof());
		_hex_char_buf->pubsync();
		return traits_type::eq_int_type(result, traits_type::eof()) ? -1 : 0;
	}

private:

	void _update_bit_buffer(char hex_char)
	{
		static StaticMap<char, std::array<char, 4>, 16> hex_to_bits
		{
			{'0', std::array{'0','0','0','0'}},
			{'1', std::array{'0','0','0','1'}},
			{'2', std::array{'0','0','1','0'}},
			{'3', std::array{'0','0','1','1'}},
			{'4', std::array{'0','1','0','0'}},
			{'5', std::array{'0','1','0','1'}},
			{'6', std::array{'0','1','1','0'}},
			{'7', std::array{'0','1','1','1'}},
			{'8', std::array{'1','0','0','0'}},
			{'9', std::array{'1','0','0','1'}},
			{'A', std::array{'1','0','1','0'}},
			{'B', std::array{'1','0','1','1'}},
			{'C', std::array{'1','1','0','0'}},
			{'D', std::array{'1','1','0','1'}},
			{'E', std::array{'1','1','1','0'}},
			{'F', std::array{'1','1','1','1'}},
		};

		_bit_buffer = &hex_to_bits.at(hex_char);
	}

	std::streambuf* _hex_char_buf;
	char _hex_char;
	std::array<char, 4>* _bit_buffer;
};

///////////////////////////////////////////////////////////////////////////////

class IStream : public std::istream
{
public:
	IStream(std::istream& is)
		: std::istream{ new Streambuf{is.rdbuf()} }
	{}

	virtual ~IStream()
	{
		delete rdbuf();
	}
};

///////////////////////////////////////////////////////////////////////////////

enum class PacketType
{
	operation_0,
	operation_1,
	operation_2,
	operation_3,
	literal_value,
	operation_5,
	operation_6,
	operation_7
};

///////////////////////////////////////////////////////////////////////////////

class Header
{
public:

	Header(std::istream& is)
		: _version{ _read_3bit_value(is) }
		, _type{ static_cast<PacketType>(_read_3bit_value(is))}
	{
	}

	uint8_t version() const { return _version; }
	PacketType type() const { return _type; }

private:

	static uint8_t _read_3bit_value(std::istream& is)
	{
		auto bit_chars = std::array{ '0', '0', '0' };
		is.read(bit_chars.data(), 3);
		if (is.fail()) {
			throw IOException("Failed to read header");
		}

		return bit_chars_to_value<uint8_t, 3>(bit_chars);
	}

	uint8_t _version;
	PacketType _type;
};

///////////////////////////////////////////////////////////////////////////////

class LiteralValuePacket {};
class OperatorPacket {};

using BitsPacket = std::variant<LiteralValuePacket, OperatorPacket>;

///////////////////////////////////////////////////////////////////////////////

}
}
}

///////////////////////////////////////////////////////////////////////////////
